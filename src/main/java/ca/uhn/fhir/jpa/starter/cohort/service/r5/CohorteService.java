package ca.uhn.fhir.jpa.starter.cohort.service.r5;

import ca.uhn.fhir.jpa.starter.cohort.service.r5.impl.CohorteServiceImpl;
import ca.uhn.fhir.jpa.starter.common.RemoteCqlClient;
import ca.uhn.fhir.jpa.starter.datamart.service.r5.utils.ResearchStudyUtils;
import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;
import ca.uhn.fhir.rest.server.exceptions.UnprocessableEntityException;

import org.hl7.fhir.r5.model.*;
import org.hl7.fhir.r5.model.Bundle.BundleEntryComponent;
import org.opencds.cqf.fhir.api.Repository;
import org.opencds.cqf.fhir.utility.search.Searches;

import java.util.Objects;

public class CohorteService implements CohorteServiceImpl {

	private final Repository repository;
	private final CohorteEvaluationOptions settings;

	public CohorteService(Repository repository, CohorteEvaluationOptions settings) {
		this.settings = settings;
		this.repository = Objects.requireNonNull(repository);
	}

	/**
	 * Performs the cohorting operation
	 *
	 * @param researchStudyUrl      The canonical URL of the {@link ResearchStudy} used as the cohorting basis.
	 * @param researchStudyEndpoint The endpoint that contains the {@link ResearchStudy} and associated resources.
	 * @param dataEndpoint          The endpoint providing access to the referenced data.
	 * @param terminologyEndpoint   The endpoint providing access to terminology (if applicable).
	 * @return A {@link Group} representing the eligible patient cohort.
	 * @throws ResourceNotFoundException if the {@link ResearchStudy} cannot be found.
	 * @throws UnprocessableEntityException if an OperationOutcome is received while searching for the {@link ResearchStudy}.
	 */
	public Group cohorting(
		CanonicalType researchStudyUrl,
		Endpoint researchStudyEndpoint,
		Endpoint dataEndpoint,
		Endpoint terminologyEndpoint,
		Endpoint cqlEngineEndpoint) {
		Repository repo = Repositories.proxy(repository, false, dataEndpoint, researchStudyEndpoint, terminologyEndpoint);
		Bundle studyBundle;
		try {
			studyBundle = repo.search(Bundle.class, ResearchStudy.class, Searches.byCanonical(researchStudyUrl.getCanonical()), null);
		} catch (Exception e) {
			throw new UnprocessableEntityException("Failed to search ResearchStudy by canonical: " + e.getMessage());
		}
		if (studyBundle.getEntry().isEmpty()) {
			var errorMsg = String.format("Unable to find ResearchStudy with url: %s", researchStudyUrl.getCanonical());
			throw new ResourceNotFoundException(errorMsg);
		}

		ResearchStudy researchStudy = null;
		OperationOutcome operationOutcome = null;
		for (BundleEntryComponent entry : studyBundle.getEntry()) {
			if (entry == null || entry.getResource() == null) continue;
			if (entry.getResource() instanceof ResearchStudy) {
				researchStudy = (ResearchStudy) entry.getResource();
				break;
			} else if (entry.getResource() instanceof OperationOutcome) {
				operationOutcome = (OperationOutcome) entry.getResource();
			}
		}
		if (researchStudy == null) {
			if (operationOutcome != null) {
				String diag = null;
				if (operationOutcome.hasIssue() && operationOutcome.getIssueFirstRep().hasDiagnostics()) {
					diag = operationOutcome.getIssueFirstRep().getDiagnostics();
				} else if (operationOutcome.hasText() && operationOutcome.getText().hasDiv()) {
					diag = operationOutcome.getText().getDivAsString();
				}
				String message = "Server returned an OperationOutcome while resolving ResearchStudy";
				if (diag != null && !diag.isBlank()) {
					message += ": " + diag;
				}
				throw new UnprocessableEntityException(message);
			}
			throw new ResourceNotFoundException("ResearchStudy with canonical '" + researchStudyUrl.getValue() + "' not found");
		}

		Parameters evaluateParams = new Parameters();
		evaluateParams.addParameter()
			.setName("dataEndpoint")
			.setResource(dataEndpoint);
		evaluateParams.addParameter()
			.setName("contentEndpoint")
			.setResource(researchStudyEndpoint);
		evaluateParams.addParameter()
			.setName("terminologyEndpoint")
			.setResource(terminologyEndpoint);

		RemoteCqlClient cqlClient = new RemoteCqlClient(cqlEngineEndpoint, repo);

		CohorteProcessor cohorteProcessor = new CohorteProcessor(repo, cqlClient, new RepositorySubjectProvider());
		Group group = cohorteProcessor.cohorting(researchStudy, evaluateParams);
		buildAndSaveGroup(repo, group, researchStudy);

		updateResearchStudyWithGroup(repo, researchStudy, group);
		return group;
	}

	/**
	 * Updates the given {@link ResearchStudy} with a reference to the given {@link Group} and update the study phase.
	 *
	 * @param repo          The repository used for updates.
	 * @param researchStudy The {@link ResearchStudy} to be updated.
	 * @param group         The {@link Group} generated by the cohorting process.
	 */
	public void updateResearchStudyWithGroup(Repository repo, ResearchStudy researchStudy, Group group) {
		researchStudy.getRecruitment().setActualGroup(new Reference(group));
		CodeableConcept phase = new CodeableConcept();
		phase.addCoding()
			.setCode("post-cohorting")
			.setSystem(ResearchStudyUtils.CUSTOM_PHASE_SYSTEM);
		researchStudy.setPhase(phase);

		repo.update(researchStudy);
	}

	/**
	 * Builds the {@link Group} properties based on the given {@link ResearchStudy} information and saves it via the repository.
	 *
	 * @param repo          The repository used to save the {@link Group}.
	 * @param group         The {@link Group} instance to build and update.
	 * @param researchStudy The {@link ResearchStudy} used as reference for group attributes.
	 */
	public void buildAndSaveGroup(Repository repo, Group group, ResearchStudy researchStudy) {
		group.setId("group" + "-" + researchStudy.getIdElement().getIdPart());
		group.setType(Group.GroupType.PERSON);
		group.setMembership(Group.GroupMembershipBasis.ENUMERATED);
		group.setActive(true);
		group.setDescription(researchStudy.getDescription());
		group.setName("Patient Eligible for: " + researchStudy.getName());
		repo.update(group);
	}
}
